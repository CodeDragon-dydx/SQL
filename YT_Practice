#Transaction_tbl has 4 columns - CustID, TranID, TranAmt and TranDate. 
#User has to display all those fields along with maximum TranAmt for each CustID and ratio of TranAmt and Maximum TranAmt for each transaction

USING SUBQUERY -
SELECT A.CustID, A.TranID, A.TranAmt, B.MaxTranAmt, (A.TranAmt/B.MaxTranAmt) AS Ratio, A.TranDate
  FROM Transaction_tbl A
  INNER JOIN (SELECT CustID, MAX(TranAmt) AS MaxTranAmt 
                FROM Transaction_tbl
                GROUP BY CustID)B
  ON A.CustID = B.CustID;
  
  USING CTE -
  
  WITH CTE(CustID, TranID, TranAmt, TranDate) AS
  (
    SELECT CustID, TranID, TranAmt, TranDate
      FROM Transaction_tbl
      ),
   WITH CTE_MAXTran(CustID, MAXTranAmt) AS
   (
    SELECT CustID, MAX(TranAmt) AS MaxTranAmt
      FROM Transaction_tbl
      GROUP BY CustID
    )
    
   SELECT A.CustID, A.TranID, A.TranAmt, (A.TranAmt/B.MaxTranAmt) AS Ratio, A.TranDate
    FROM CTE A
    INNER JOIN CTE_MaxTran B
    ON A.CustID = B.CustID;

# Given below table EMP an input which has the column s 'Group' and 'Sequence' 
# write a SQL query to find the maximum and minimum values of continuous sequence in each group

Input - SELECT * FROM EMP; - Group, Sequence
Output - Group, Min_Seq, Max_Seq

STEP #1

SELECT Group,
        Sequence,
        ROW_NUMBER() OVER(PARTITION BY Group ORDER BY Sequence) AS rnk
  FROM EMP;
  
  STEP #2
 
 SELECT Group,
        Sequence,
        ROW_NUMBER() OVER(PARTITION BY Group ORDER BY Sequence) AS rnk,
        Sequence - ROW_NUMBER() OVER(PARTITION BY Group ORDER BY Sequence) AS split 
  FROM EMP;
  
STEP #3

SELECT Group, 
        MIN(Sequence) AS Min_Seq,
        MAX(Sequence) AS Max_Seq
  FROM
  (
    SELECT Group,
            Sequence,
            Sequence - ROW_NUMBER() OVER(PARTITION BY Group ORDER BY Sequence) AS Split 
      FROM EMP
      )temp
    GROUP BY Group, Split
    ORDER BY Group;

# Student Table has 3 columns -> student_name, total_marks, year
# User has to write a SQL query to display student_name, total_marks, year, prev_yr_marks for those whose total marks are greater than or equal to the previous year

SELECT student_name, 
        year, 
         total_marks,
         prev_yr_marks 
  FROM
  (SELECT student_name, 
          year, 
          total_marks,
          prev_yr_marks, 
          CASE WHEN total_marks >= prev_yr_marks THEN 1 ELSE 0 END AS Flag
    FROM
    (SELECT student_name, 
            total_marks, 
            year, 
            LAG(total_marks) OVER(PARTITION BY student_name ORDER BY year) AS prev_yr_marks
      FROM Student
      )A
  )B
WHERE Flag = 1;

# Product's price for each store
# Products Table -> Product_id, Store, Price 
# Output -> Product_id, Store1, Store2, Store3

SELECT P1.product_id,
        P2.Price AS Store1.
        P3.Price AS Store2,
        P4.Price AS Store3
  FROM Products P1
  LEFT JOIN Products P2 ON P1.product_id = P2.product_id AND P2.Store = 'Store1'
  LEFT JOIN Products P3 ON P1.product_id = P3.product_id AND P3.Store = 'Store2'
  LEFT JOIN Products P4 ON P1.product_id = P4.product_id AND P4.Store = 'Store3'
  GROUP BY product_id
  ORDER BY product_id;
  
  ((OR))
  
  SELECT product_id,
          MAX(CASE WHEN store = 'Store1' THEN Price END) AS Store1,
          MAX(CASE WHEN store = 'Store2' THEN Price END) AS Store2,
          MAX(CASE WHEN store = 'Store3' THEN Price END) AS Store3
    FROM Products
    GROUP BY product_id
    ORDER BY product_id;

# Using PIVOT function. This works only in MS SQL Server

SELECT product_id, [Store1], [Store2], [Store3]
  FROM Products
  PIVOT(
          MAX(Price)
          FOR Store IN ([Store1],[Store2],[Store3])
          )AS PivotTable
          
# Rearrange Products table
  
  SELECT product_id,
          store,
          price
     FROM Products
     UNPIVOT
     (
        Price
        FOR Store IN ( Store1, Store2, Store3)
        )AS a
