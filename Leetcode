- Combine Two Tables
  Write a SQL query for a report that provides the following information for each person in the Person table, regardless if there is an address for each of those people:
  FirstName, LastName, City, State
  
  SELECT P.FirstName,
         P.LastName,
         A.City,
         A.State
    FROM Person P
    LEFT JOIN Address A
    ON P.PersonID = A.PersonID;
    
    
- Employee Bonus
  Select all employee's name and bonus whose bonus is < 1000
  
  SELECT E.name,
         B.bonus
    FROM Employee E
    LEFT JOIN Bonus B
    ON E.empID = B.empID
    WHERE B.bonus is null or B.bonus < 1000;
    
    
- Second Highest Salary
  Write a SQL query to get the second highest salary from the Employee table.
  
  SELECT MAX(Salary) AS SecondHighestSalary
    FROM Employee
    WHERE Salary < (
                        SELECT MAX(Salary)
                            FROM Employee
                    );
                    
                    ((OR))
                    
 SELECT 
    IFNULL(
            (SELECT DISTINCT Salary
                FROM Employee
                ORDER BY Salary Desc
                LIMIT 1 OFFSET 1),
                NULL
            ) AS SecondHighestSalary
            
            
- Nth Highest Salary
  Write a SQL query to get the nth highest salary from the Employee table.
  
  CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
    BEGIN
    RETURN (
              SELECT DISTINCT SALARY
                  FROM
                      (
                        SELECT Salary,
                                DENSE_RANK() OVER (ORDER BY SALARY DESC) AS RK
                            FROM Employee
                        )T
             WHERE RK = N
          );
  END


            ((OR))
            
  CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
  BEGIN
  SET N=N-1;
  RETURN (
            SELECT IFNULL
            (
                (
                    SELECT DISTINCT Salary 
                      FROM Employee 
                      ORDER BY Salary DESC LIMIT 1 OFFSET N
                ), NULL
              )              
       );
  END
  
- Recyclable and Low Fat Products
  Write an SQL query to find the ids of products that are both low fat and recyclable.
  
  SELECT product_id
    FROM Products
    WHERE low_fats = 'Y'
    AND recyclable = 'Y';

- Find Total Time Spent by Each Employee
  Write an SQL query to calculate the total time in minutes spent by each employee on each day at the office. 
  Note that within one day, an employee can enter and leave more than once. 
  The time spent in the office for a single entry is out_time - in_time.
  
  SELECT event_day AS day,
       emp_id,
       SUM(out_time - in_time) AS total_time
    FROM Employees
    GROUP BY day, emp_id;
    
- Daily Leads and Partners

  SELECT date_id, 
       make_name,
       count(DISTINCT lead_id) AS unique_leads,
       count(DISTINCT partner_id) AS unique_partners
    FROM DailySales
    GROUP BY date_id, make_name;
    
    ((OR))
    
   WITH cte_lead AS
    (
        SELECT date_id, make_name, COUNT(DISTINCT lead_id) AS unique_leads
            FROM DailySales
            GROUP BY date_id, make_name
        ),
cte_partner AS
    (
        SELECT date_id, make_name, COUNT(DISTINCT partner_id) AS unique_partners
            FROM DailySales
            GROUP BY date_id, make_name        
        )
SELECT A.date_id, A.make_name, A.unique_leads, B.unique_partners
    FROM cte_lead A
    INNER JOIN cte_partner B
    ON A.date_id = B.date_id AND A.make_name = B.make_name;
    
- Invalid Tweets
  SELECT tweet_id 
    FROM Tweets
    WHERE LENGTH(content) > 15;
    
- Students With Invalid Departments
  Write an SQL query to find the id and the name of all students who are enrolled in departments that no longer exists.
  
  SELECT ID,Name
    FROM Students
    WHERE department_id NOT IN
    (
        SELECT DISTINCT ID
            FROM Departments
    );
    
    ((OR))
    
  SELECT S.ID,
       S.Name
    FROM Students S
    LEFT JOIN Departments D
    on S.Department_ID = D.ID
    where D.ID IS NULL;
    
- Replace Employee ID With The Unique Identifier
  Write an SQL query to show the unique ID of each user, If a user doesn't have a unique ID replace just show null.
  
  SELECT EUNI.unique_id, E.name
    FROM EmployeeUNI as EUNI
    RIGHT JOIN Employees E
    ON E.id = EUNI.id;

- Bank Account Summary II
  Write an SQL query to report the name and balance of users with a balance higher than 10000. 
  The balance of an account is equal to the sum of the amounts of all transactions involving that account.
  
  SELECT U.Name, SUM(T.Amount) AS balance
    FROM Transactions T
    INNER JOIN Users U
    ON T.Account = U.Account
    GROUP BY U.Name
    HAVING balance > 10000;
    
    ((OR))
    
    WITH cte_trans AS
  (
    SELECT account, SUM(amount) AS balance
        FROM Transactions 
        GROUP BY account
        HAVING SUM(amount)>10000
     )
    
    SELECT U.name, C.balance
    FROM Users U
    INNER JOIN cte_trans C
    ON U.account = C.account;
    
    
- Warehouse Manager
  Write an SQL query to report, How much cubic feet of volume does the inventory occupy in each warehouse.

    warehouse_name
    volume
    
  SELECT W.Name AS WAREHOUSE_NAME,
       SUM(W.Units*P.Width*P.Length*P.Height) as VOLUME
       FROM Warehouse W
       INNER JOIN Products P
       ON W.Product_ID = P.Product_ID
       Group BY W.Name;
       
- Customer Who Visited but Did Not Make Any Transactions
  Write an SQL query to find the IDs of the users who visited without making any transactions and the number of times they made these types of visits.
  
  SELECT V.customer_id, COUNT(V.VISIT_ID) AS count_no_trans
    FROM Visits V
    LEFT JOIN Transactions T
    ON V.Visit_ID = T.Visit_ID
    WHERE T.VISIT_id IS NULL
    GROUP BY V.Customer_ID
    
  - Find the Team Size
    Write an SQL query to find the team size of each of the employees.
    
    SELECT employee_id,
        COUNT(team_id) OVER(PARTITION BY team_id) AS team_size 
      FROM Employee
      GROUP BY employee_id;
      
      
      ((OR))
     
     SELECT a.employee_id,
        t.team_size
      FROM Employee a
      LEFT JOIN (SELECT team_id, count(*) as team_size
                  FROM Employee
                  GROUP BY team_id
                  )t
      ON a.team_id = t.team_id; 

- All Valid Triplets That Can Represent a Country
  There is a country with three schools, where each student is enrolled in exactly one school. The country is joining a competition and wants to select one student from each school to represent the country such that:

  member_A is selected from SchoolA,
  member_B is selected from SchoolB,
  member_C is selected from SchoolC, and
  The selected students' names and IDs are pairwise distinct (i.e. no two students share the same name, and no two students share the same ID).
  Write an SQL query to find all the possible triplets representing the country under the given constraints.
  
  SELECT a.student_name AS member_A,
        b.student_name AS member_B,
        c.student_name AS member_C
    FROM SchoolA a
        CROSS JOIN SchoolB b
        CROSS JOIN SchoolC c
    WHERE a.student_name != b.student_name
    AND a.student_name != c.student_name
    AND b.student_name != c.student_name
    AND a.student_id != b.student_id
    AND a.student_id != c.student_id
    AND b.student_id != c.student_id;

- Product's Price for Each Store
  Write an SQL query to find the price of each product in each store.
  
  select product_id,
       sum(if(store='store1', price, null)) as store1,
       sum(if(store='store2', price, null)) as store2,
       sum(if(store='store3', price, null)) as store3
    from products
    group by product_id;
    
      ((or))
      
    SELECT p1.product_id,
        p2.price as store1,
        p3.price as store2,
        p4.price as store3
    FROM Products p1 
    LEFT JOIN Products p2 on p1.product_id = p2.product_id and p2.store = 'store1'
    LEFT JOIN Products p3 on p1.product_id = p3.product_id and p3.store = 'store2'
    LEFT JOIN Products p4 on p1.product_id = p4.product_id and p4.store = 'store3'
    GROUP BY product_id
    ORDER BY product_id;
    
- Rearrange Products Table
  Write an SQL query to rearrange the Products table so that each row has (product_id, store, price). 
  If a product is not available in a store, do not include a row with that product_id and store combination in the result table. 
  
  (
    SELECT product_id, 'store1' AS store, store1 AS price
        FROM Products
        WHERE store1 IS NOT NULL
    )
UNION
(
    SELECT product_id, 'store2' AS store, store2 AS price
        FROM Products
        WHERE store2 IS NOT NULL
    )
UNION
(
    SELECT product_id, 'store3' AS store, store3 AS price
        FROM Products
        WHERE store3 IS NOT NULL
    )
ORDER BY 1,2;

((OR))
/////MS SQL
SELECT product_id, store, price
    FROM Products
    UNPIVOT
    (
        price
        FOR store IN (store1, store2,store3)
    )s;
    
    ((OR))
  //ORACLE
  SELECT 
    product_id,
    store,
    price
FROM Products
UNPIVOT
(
	price
	FOR store in (store1 AS 'store1',store2 AS 'store2',store3 AS 'store3')
);
    
- Group Sold Products By The Date

  Write an SQL query to find for each date, the number of distinct products sold and their names.
  The sold-products names for each date should be sorted lexicographically. 
  Return the result table ordered by sell_date.
  The query result format is in the following example.
  
  SELECT sell_date,
        COUNT(DISTINCT product) AS num_sold,
        GROUP_CONCAT(DISTINCT product 
                     ORDER BY product) AS products
    FROM Activities
    GROUP BY sell_date
    ORDER BY sell_date;

- Top Travellers
   Write an SQL query to report the distance travelled by each user.

    Return the result table ordered by travelled_distance in descending order, if two or more users travelled the same distance, order them by their name in ascending order.
    
    SELECT  u.name,
        IFNULL(SUM(R.distance),0) as travelled_distance
        FROM Users u
        LEFT JOIN Rides r
        ON u.id = r.user_id
        GROUP BY u.name
        ORDER BY travelled_distance DESC, 
                    u.name;
                    
                    ((OR))
                    
     SELECT  u.name,
        CASE WHEN SUM(R.distance) IS NOT NULL
            THEN SUM(R.distance)
            ELSE 0
            END AS travelled_distance
        FROM Users u
        LEFT JOIN Rides r
        ON u.id = r.user_id
        GROUP BY u.name
        ORDER BY travelled_distance DESC, 
                    u.name;
  
- Product Sales Analysis II
  Write an SQL query that reports the total quantity sold for every product id.
  
  SELECT S.product_id,
        SUM(S.quantity) as total_quantity
    FROM Sales S
    INNER JOIN Product P
    ON S.product_id = P.product_id
    GROUP BY S.product_id;
    
- Unique Orders and Customers Per Month

  Write an SQL query to find the number of unique orders and the number of unique customers with invoices > $20 for each different month.
  Return the result table sorted in any order.
  
  SELECT DATE_FORMAT(order_date, '%Y-%m') AS month,
        COUNT(DISTINCT order_id) AS order_count,
        COUNT(DISTINCT customer_id) AS customer_count
    FROM Orders
    WHERE invoice > 20
    GROUP BY month;
    
    ((OR))
    
    SELECT SUBSTRING(order_date, 1,7) AS month,
        COUNT(DISTINCT order_id) AS order_count,
        COUNT(DISTINCT customer_id) AS customer_count
      FROM Orders
      WHERE invoice > 20
      GROUP BY month;

- Average Selling Price

  Write an SQL query to find the average selling price for each product.
  average_price should be rounded to 2 decimal places.
  
  SELECT P.product_id, 
    ROUND(SUM(U.units*P.price)/ SUM(U.units),2) AS average_price
    FROM Prices P
    INNER JOIN UnitsSold U
    ON P.product_id = U.product_id 
        AND U.purchase_date BETWEEN P.start_date AND P.end_date
    GROUP BY P.product_id;
    
- Immediate Food Delivery I

  If the preferred delivery date of the customer is the same as the order date then the order is called immediate otherwise it's called scheduled.
  Write an SQL query to find the percentage of immediate orders in the table, rounded to 2 decimal places.
  
  SELECT ROUND(
                (
                        (
                            COUNT(*)*100)/(SELECT COUNT(*) FROM Delivery
                          )
                  )
            , 2) AS immediate_percentage
      FROM Delivery 
      WHERE order_date = customer_pref_delivery_date;
      

  SELECT ROUND((immediate*100)/total, 2) AS immediate_percentage
    FROM
        (
            SELECT COUNT(delivery_id) as immediate 
                FROM Delivery
                WHERE order_date = customer_pref_delivery_date
        ) AS temp1,
        (
            SELECT COUNT(delivery_id) as total 
                FROM Delivery
        ) AS temp2;

- Product Sales Analysis I

  Write an SQL query that reports the product_name, year, and price for each sale_id in the Sales table.
  
  SELECT product_name, year, price
    FROM
    (
        SELECT S.sale_id, P.product_name, S.year, S.price
            FROM Sales S
            INNER JOIN Product P
            ON S.product_id = P.product_id
        ) AS A;
        
        ((or))
   SELECT P.product_name, S.year, S.price
      FROM Sales S
      INNER JOIN Product P
        ON S.product_id = P.product_id;

- Reformat Department Table
  Write an SQL query to reformat the table such that there is a department id column and a revenue column for each month.

//MS SQL Server Solution

  SELECT ID, Jan AS Jan_Revenue,
              Feb AS Feb_Revenue,
              Mar AS Mar_Revenue,
              Apr AS Apr_Revenue,
              May AS May_Revenue,
              Jun AS Jun_Revenue,
              Jul AS Jul_Revenue,
              Aug AS Aug_Revenue,
              Sep AS Sep_Revenue,
              Oct AS Oct_Revenue,
              Nov AS Nov_Revenue,
              Dec AS Dec_Revenue
      FROM Department
      PIVOT
      (
          SUM(revenue)
          FOR month
          IN ([Jan],[Feb],[Mar],[Apr],[May],[Jun],[Jul],[Aug],[Sep],[Oct],[Nov],[Dec])
          ) AS PivotTable;
        
        ((or))
    
    SELECT ID, 
        SUM(IF(month = 'Jan', revenue, null)) AS Jan_Revenue,
        SUM(IF(month = 'Feb', revenue, null)) AS Feb_Revenue,
        SUM(IF(month = 'Mar', revenue, null)) AS Mar_Revenue,
        SUM(IF(month = 'Apr', revenue, null)) AS Apr_Revenue,
        SUM(IF(month = 'May', revenue, null)) AS May_Revenue,
        SUM(IF(month = 'Jun', revenue, null)) AS Jun_Revenue,
        SUM(IF(month = 'Jul', revenue, null)) AS Jul_Revenue,
        SUM(IF(month = 'Aug', revenue, null)) AS Aug_Revenue,
        SUM(IF(month = 'Sep', revenue, null)) AS Sep_Revenue,
        SUM(IF(month = 'Oct', revenue, null)) AS Oct_Revenue,
        SUM(IF(month = 'Nov', revenue, null)) AS Nov_Revenue,
        SUM(IF(month = 'Dec', revenue, null)) AS Dec_Revenue
    FROM Department
    GROUP BY ID;
    
        ((or))
        
    SELECT d.id, 
        d1.revenue AS Jan_Revenue,
        d2.revenue AS Feb_Revenue,
        d3.revenue AS Mar_Revenue,
        d4.revenue AS Apr_Revenue,
        d5.revenue AS May_Revenue,
        d6.revenue AS Jun_Revenue,
        d7.revenue AS Jul_Revenue,
        d8.revenue AS Aug_Revenue,
        d9.revenue AS Sep_Revenue,
        d10.revenue AS Oct_Revenue,
        d11.revenue AS Nov_Revenue,
        d12.revenue AS Dec_Revenue
    FROM Department AS d
    LEFT JOIN Department AS d1
        ON d.id = d1.id AND d1.month = 'Jan'
    LEFT JOIN Department AS d2
        ON d.id = d2.id AND d2.month = 'Feb'
    LEFT JOIN Department AS d3
        ON d.id = d3.id AND d3.month = 'Mar'
    LEFT JOIN Department AS d4
        ON d.id = d4.id AND d4.month = 'Apr'
    LEFT JOIN Department AS d5
        ON d.id = d5.id AND d5.month = 'May'
    LEFT JOIN Department AS d6
        ON d.id = d6.id AND d6.month = 'Jun'
    LEFT JOIN Department AS d7
        ON d.id = d7.id AND d7.month = 'Jul'
    LEFT JOIN Department AS d8
        ON d.id = d8.id AND d8.month = 'Aug'
    LEFT JOIN Department AS d9
        ON d.id = d9.id AND d9.month = 'Sep'
    LEFT JOIN Department AS d10
        ON d.id = d10.id AND d10.month = 'Oct'
    LEFT JOIN Department AS d11
        ON d.id = d11.id AND d11.month = 'Nov'
    LEFT JOIN Department AS d12
        ON d.id = d12.id AND d12.month = 'Dec'
    GROUP BY ID;

- Game Play Analysis I
  Write an SQL query that reports the first login date for each player.
  
  SELECT player_id, MIN(event_date) AS first_login
    FROM Activity
    GROUP BY player_id;
    
    ((OR))
  
  SELECT player_id, event_date AS first_login
    FROM
    (
        SELECT *, DENSE_RANK() OVER (PARTITION BY player_id
                                 ORDER BY event_date
                                ) AS DRK
        FROM Activity
        ) temp
    WHERE temp.DRK = 1;
- Shortest Distance in a Line
  Table point holds the x coordinate of some points on x-axis in a plane, which are all integers.
  Write a query to find the shortest distance between two points in these points.
  
  SELECT MIN(ABS(a.x - b.x)) AS shortest
    FROM point a, point b
    WHERE a.x <> b.x;
       ((OR))
       
   SELECT DISTINCT MIN(t1.distance) AS shortest
    FROM (
            SELECT ABS(a.x-b.x) as distance
                FROM point a
                CROSS JOIN point b
                ) t1
    WHERE distance > 0;

- Average Time of Process per Machine
  There is a factory website that has several machines each running the same number of processes. Write an SQL query to find the average time each machine takes to complete a process.
  The time to complete a process is the 'end' timestamp minus the 'start' timestamp. The average time is calculated by the total time to complete every process on the machine divided by the number of processes that were run.
  The resulting table should have the machine_id along with the average time as processing_time, which should be rounded to 3 decimal places.
  
  SELECT a.machine_id, 
        ROUND(AVG(b.timestamp - a.timestamp),3) AS processing_time
    FROM Activity a 
    JOIN Activity b
        ON a.machine_id = b.machine_id
        AND a.process_id = b.process_id
    WHERE a.activity_type = 'start' AND b.activity_type = 'end'
    GROUP BY a.machine_id;

- Ad-Free Sessions
  Write an SQL query to report all the sessions that did not get shown any ads.
  Return the result table in any order.
  
  SELECT pb.session_id
    FROM playback pb LEFT JOIN ads ad
        ON pb.customer_id = ad.customer_id
        AND ad.timestamp BETWEEN pb.start_time and pb.end_time
    WHERE ad.customer_id IS NULL;

- Primary Department for Each Employee

    SELECT DISTINCT employee_id, department_id
      FROM Employee
      WHERE primary_flag = 'Y'
      OR employee_id IN
     (
        SELECT employee_id 
            FROM Employee
            GROUP BY employee_id
            HAVING COUNT(department_id) = 1 
        );
         ((OR))
         
      SELECT employee_id, department_id
      FROM Employee
      WHERE primary_flag = 'Y'
      UNION
        SELECT employee_id, department_id 
            FROM Employee
            GROUP BY employee_id
            HAVING COUNT(department_id) = 1 ;

- Big Countries

  A country is big if it has an area of bigger than 3 million square km or a population of more than 25 million.
  Write a SQL solution to output big countries' name, population and area.
  
  SELECT name, population, area
    FROM World
    WHERE area > 3000000
    OR population > 25000000;

- Swap Salary
  Write an SQL query to swap all 'f' and 'm' values (i.e., change all 'f' values to 'm' and vice versa) with a single update statement and no intermediate temp table(s).
  Note that you must write a single update statement, DO NOT write any select statement for this problem.
  
  UPDATE Salary
    SET sex = CASE WHEN sex = 'm' then 'f'
    ELSE 'm'
  END;

- You want to know how long a user visits your application. 
  You decided to create bins of "[0-5>", "[5-10>", "[10-15>" and "15 minutes or more" and count the number of sessions on it.
  Write an SQL query to report the (bin, total) in any order.
  
  SELECT '[0-5>' AS bin,
        SUM(CASE WHEN duration/60 < 5 THEN 1 ELSE 0 END) AS total
    FROM Sessions
  UNION ALL
  SELECT '[5-10>' AS bin,
        SUM(CASE WHEN duration/60 BETWEEN 5 AND 10 THEN 1 ELSE 0 END) AS total
    FROM Sessions
  UNION ALL
  SELECT '[10-15>' AS bin,
        SUM(CASE WHEN duration/60 BETWEEN 10 AND 15 THEN 1 ELSE 0 END) AS total
    FROM Sessions
  UNION ALL
  SELECT '15 or more' AS bin,
        SUM(CASE WHEN duration/60 > 15 THEN 1 ELSE 0 END) AS total
    FROM Sessions;
  
    ((OR))
    
  SELECT '[0-5>' AS bin,
        SUM(IF(duration/60 < 5, 1, 0)) AS total
    FROM Sessions
  UNION ALL
  SELECT '[5-10>' AS bin,
        SUM(IF(duration/60 > 5 AND duration/60 < 10, 1, 0)) AS total
    FROM Sessions
  UNION ALL
  SELECT '[10-15>' AS bin,
        SUM(IF(duration/60 > 10 AND duration/60 < 15, 1, 0)) AS total
    FROM Sessions
  UNION ALL
  SELECT '15 or more' AS bin,
        SUM(IF(duration/60 > 15, 1, 0)) AS total
    FROM Sessions;

- List the Products Ordered in a Period

  Write an SQL query to get the names of products with greater than or equal to 100 units ordered in February 2020 and their amount.
  
  SELECT P.product_name, 
        SUM(O.unit) AS unit
    FROM Products P
    INNER JOIN Orders O
        ON P.product_id = O.product_id
    WHERE YEAR(O.order_date) = '2020' AND MONTH(O.order_date) = '02'
    #O.order_date >= '2020-02-01' AND O.order_Date <= '2020-02-28'
    GROUP BY P.product_name
    HAVING SUM(O.unit) >= 100;
    
- Article Views I

  Write an SQL query to find all the authors that viewed at least one of their own articles, sorted in ascending order by their id.

  SELECT DISTINCT author_id AS id
    FROM Views
    WHERE author_id = viewer_id
    ORDER BY id;
- Customer Placing the Largest Number of Orders

  Write an SQL query to find the customer_number for the customer who has placed the largest number of orders.
  It is guaranteed that exactly one customer will have placed more orders than any other customer.
  
  SELECT customer_number
    FROM
      (
          SELECT customer_number, COUNT(order_number)
              FROM Orders
              GROUP BY customer_number
              ORDER BY COUNT(order_number) DESC
              LIMIT 1
          )O;
- Students and Examinations
  Write an SQL query to find the number of times each student attended each exam.
  Order the result table by student_id and subject_name.
  
  SELECT a.student_id, 
        a.student_name,
        b.subject_name,
        COUNT(c.subject_name) AS attended_exams
    FROM students AS a
    JOIN subjects AS b
    LEFT JOIN examinations AS c
        ON a.student_id = c.student_id AND b.subject_name = c.subject_name
    GROUP BY a.student_id, b.subject_name
    ORDER BY a.student_id, b.subject_name;
  
- Find Customers With Positive Revenue this Year
  Write an SQL query to report the customers with postive revenue in the year 2021.
  Return the result table in any order.
  
  SELECT customer_id
    FROM Customers
    WHERE year = 2021 AND revenue > 0;

- Find Customer Referee
  Write a query to return the list of customers NOT referred by the person with id '2'.
  
  SELECT name
    FROM customer
    WHERE referee_id <> 2 or referee_id is null;
    ((or))
  SELECT name
    FROM customer
    WHERE referee_id <> 2
    UNION ALL
    SELECT name
    FROM customer
    WHERE referee_id is null;
    
- Customer Order Frequency
  Write an SQL query to report the customer_id and customer_name of customers who have spent at least $100 in each month of June and July 2020.
  Return the result table in any order.
  
  SELECT C.customer_id, C.name 
    FROM Customers C
    JOIN
(
    SELECT O.customer_id, LEFT(O.order_date, 7) AS date, SUM(P.price * O.quantity) AS total
        FROM Product P
        JOIN Orders O 
        ON P.product_id = O.product_id
        WHERE LEFT(O.order_date, 7) in ('2020-06','2020-07')
        GROUP BY O.customer_id, date
        HAVING SUM(P.price * O.quantity) >= 100
    )T
    ON C.customer_id = T.customer_id
    GROUP BY C.customer_id
    HAVING COUNT(*) = 2;

- Sales Analysis I
  Write an SQL query that reports the best seller by total sales price, If there is a tie, report them all.
  
  with total as(
                SELECT seller_id, SUM(price) AS total_sales
                    FROM Sales
                    GROUP BY seller_id
                )
                
SELECT seller_id 
    FROM total
    WHERE total_sales = (
                            SELECT MAX(total_sales)
                                FROM total
                            );
                            
                            ((or))
                            
 SELECT seller_id
    FROM
    (
        SELECT seller_id, 
                RANK() OVER (ORDER BY SUM(price) desc) as rnk
            FROM Sales
            GROUP BY seller_id
        )rk
        where rnk = 1;
- Actors and Directors Who Cooperated At Least Three Times
  Write a SQL query for a report that provides the pairs (actor_id, director_id) where the actor have cooperated with the director at least 3 times.
  
     SELECT actor_id, director_id
        FROM ActorDirector 
        GROUP BY 1,2
        HAVING COUNT(*) >=3; 
        
        ((or))
        
      SELECT actor_id, director_id
    FROM
    (
        SELECT actor_id, director_id, CONCAT(actor_id, director_id) AS unique_id
            FROM ActorDirector 
            GROUP BY 1,2
            HAVING COUNT(unique_id) > 2
        )a; 

- Employee Bonus
  Select all employee's name and bonus whose bonus is < 1000.
  SELECT E.name, B.bonus
    FROM Employee E
    LEFT JOIN Bonus B
    ON E.empId = B.empId
    WHERE B.bonus < 1000 OR B.bonus IS NULL;

- Percentage of Users Attended a Contest
  Write an SQL query to find the percentage of the users registered in each contest rounded to two decimals.
  Return the result table ordered by percentage in descending order. In case of a tie, order it by contest_id in ascending order.
  
  select distinct contest_id,
        round(count(user_id)/(select count(*) from users)*100,2) as "percentage"
    from Register
    group by contest_id
    order by 2 desc, 1;

    ((OR))
    
    select a.contest_id,
		round((total /count(user_id))*100 , 2) as percentage
	from Users u join(
				select contest_id,
					count(distinct user_id) as total
				     from Register
				     group by contest_id) as a
	group by a.contest_id
	order by round((total /count(user_id))*100 , 2) desc , a.contest_id asc;

- Find Followers Count
  Write an SQL query that will, for each user, return the number of followers.
  Return the result table ordered by user_id.
  
  SELECT user_id, COUNT(follower_id) AS followers_count
    FROM Followers
    GROUP BY user_id
    ORDER BY user_id;
  
- Find Users With Valid E-Mails
  Write an SQL query to find the users who have valid emails.
  A valid e-mail has a prefix name and a domain where: 
  The prefix name is a string that may contain letters (upper or lower case), digits, underscore '_', period '.' and/or dash '-'. The prefix name must start with a letter.
  The domain is '@leetcode.com'.
  Return the result table in any order.
  
  SELECT * 
    FROM Users
    WHERE mail REGEXP '^[A-Za-z][A-Za-z0-9_.-]*@leetcode.com$';
    
- Not Boring Movies
  X city opened a new cinema, many people would like to go to this cinema. The cinema also gives out a poster indicating the movies’ ratings and descriptions.
  Please write a SQL query to output movies with an odd numbered ID and a description that is not 'boring'. Order the result by rating.
  
  SELECT id, movie, description, rating
    FROM cinema
    WHERE id%2 <> 0 AND description <> 'boring'
    ORDER BY rating DESC;
    
-  Queries Quality and Percentage
   We define query quality as:
   The average of the ratio between query rating and its position.
   We also define poor query percentage as:
   The percentage of all queries with rating less than 3.
   Write an SQL query to find each query_name, the quality and poor_query_percentage.
   Both quality and poor_query_percentage should be rounded to 2 decimal places.

   SELECT query_name, 
        ROUND(AVG(rating/position), 2) AS quality, 
        ROUND(100*AVG(rating < 3),2) AS poor_query_percentage
     FROM Queries
     GROUP BY query_name;
- A pupil Tim gets homework to identify whether three line segments could possibly form a triangle.
  However, this assignment is very heavy because there are hundreds of records to calculate.
  Could you help Tim by writing a query to judge whether these three sides can form a triangle, assuming table triangle holds the length of the three sides x, y and z.
  
  SELECT x,y,z, IF(x+y>z AND y+z>x AND x+z>y, "Yes", "No") AS triangle
    FROM triangle;
- Number of Comments per Post
  Write an SQL query to find number of comments per each post.
  Result table should contain post_id and its corresponding number_of_comments, and must be sorted by post_id in ascending order.
  Submissions may contain duplicate comments. You should count the number of unique comments per post.
  Submissions may contain duplicate posts. You should treat them as one post.
  
  SELECT P.sub_id AS post_id,
       COUNT(DISTINCT S.sub_id) AS number_of_comments
    FROM Submissions P 
    LEFT JOIN Submissions S
    ON P.sub_id = S.parent_id
    WHERE p.parent_id IS NULL
    GROUP BY p.sub_id;
      ((OR))
      
    WITH cte_post AS
   (
    SELECT DISTINCT sub_id AS post_id
        FROM Submissions
        WHERE parent_id IS NULL
   )

  SELECT post_id, COUNT(DISTINCT sub_id) AS number_of_comments
      FROM cte_post c 
      LEFT JOIN Submissions S
      ON c.post_id = S.parent_id
      GROUP BY post_id;

- Consecutive Available Seats
  Several friends at a cinema ticket office would like to reserve consecutive available seats.
  Can you help to query all the consecutive available seats order by the seat_id using the following cinema table?
  
  SELECT DISTINCT a.seat_id
    FROM cinema a
    JOIN cinema b
    ON ABS(a.seat_id - b.seat_id) = 1
    AND a.free = 1
    AND b.free = 1
    ORDER BY a.seat_id;
    
    ((OR))
    
  SELECT DISTINCT a.seat_id
    FROM cinema a
    JOIN cinema b
    ON a.free = 1
    AND b.free = 1
    AND (a.seat_id+1 = b.seat_id OR b.seat_id + 1 = a.seat_id)
    ORDER BY a.seat_id;
    
    ((OR))
    
  SELECT temp.seat_id
    FROM (
            SELECT seat_id, free,
                   LAG(free) OVER(ORDER BY seat_id ASC) AS free_lag,
                   LEAD(free) OVER(ORDER BY seat_id ASC) AS free_lead
                FROM cinema
            ) temp
    WHERE (free AND free_lag) OR (free AND free_lead) = 1
    ORDER BY temp.seat_id ASC;

- Sales Analysis III
  Write an SQL query that reports the products that were only sold in spring 2019. That is, between 2019-01-01 and 2019-03-31 inclusive.
  
  SELECT product_id, product_name 
	FROM Product 
	WHERE product_id IN
	(
    		SELECT product_id
        		FROM Sales 
        		GROUP BY product_id
        		HAVING MAX(sale_date) <= '2019-03-31' AND MIN(sale_date) >= '2019-01-01'
    		);

- Friendly Movies Streamed Last Month
  Write an SQL query to report the distinct titles of the kid-friendly movies streamed in June 2020.
  
  SELECT DISTINCT C.title
    FROM TVProgram T
    INNER JOIN Content C
    ON T.content_id = C.content_id 
    WHERE T.program_date LIKE '2020-06%' AND C.kids_content = 'Y' AND C.content_type = 'Movies';
  
- Sales Analysis II
  Write an SQL query that reports the buyers who have bought S8 but not iPhone. Note that S8 and iPhone are products present in the Product table.
  
  SELECT DISTINCT(S.buyer_id)
    FROM Product P
    INNER JOIN Sales S
    ON P.product_id = S.product_id
    WHERE P.product_name = 'S8' AND
    S.buyer_id NOT IN 
        (
            SELECT DISTINCT(S.buyer_id)
                FROM Product P
                INNER JOIN Sales S
                ON P.product_id = S.product_id
                WHERE P.product_name = 'iPhone'
            );
- Delete Duplicate Emails
  Write a SQL query to delete all duplicate email entries in a table named Person, keeping only unique emails based on its smallest Id.
  
  DELETE p1.*
	FROM Person p1,
     	     Person p2
	WHERE p1.Email = p2.Email AND p1.Id > p2.Id;

- Grand Slam Titles
  Write an SQL query to report the number of grand slam tournaments won by each player. Do not include the players who did not win any tournament.
  Return the result table in any order.
  
  
with temp AS (
	SELECT Wimbledon AS player_id FROM Championships
		UNION ALL SELECT Fr_open AS player_id FROM Championships
		UNION ALL SELECT US_open AS player_id FROM Championships
		UNION ALL SELECT Au_open AS player_id From Championships
)

SELECT temp.player_id, p.player_name, COUNT(*) AS grand_slams_count
	FROM temp
	LEFT JOIN Players p
	ON temp.player_id=p.player_id
	GROUP BY temp.player_id;

- All People Report to the Given Manager
  Write an SQL query to find employee_id of all employees that directly or indirectly report their work to the head of the company.
  The indirect relation between managers will not exceed 3 managers as the company is small.
  Return result table in any order without duplicates.
  
  SELECT DISTINCT a.employee_id
    FROM Employees a, Employees b, Employees c, Employees d
    WHERE a.manager_id = b.employee_id AND
          b.manager_id = c.employee_id AND
          c.manager_id = d.employee_id AND
          d.manager_id = 1 AND a.employee_id != 1;

     ((OR))
  #Recursive CTE
  with recursive cte as (
    select employee_id, 1 as n
    from   employees
    where  manager_id=1 and employee_id<>1
    union all
    select a.employee_id, n+1 as n
    from   employees a join cte b on (b.employee_id=a.manager_id) 
    where  n+1<4
)
select employee_id from cte
 ####Comments for Recursive CTE
 Similar to the previous solution, we need to join 4 tables together. However, we are now doing this recursively.
 The anchor statement below is the starting point for the recursive CTE. For this problem, this would be all individuals who are direct reporters to the manager.

    select employee_id, 1 as n
    from   employees
    where  manager_id=1 and employee_id<>1
  I use union all as there aren't any duplicates expected in this table (no multiple reporters to different managers) and it is faster than union.

  For the recursive member of the CTE shown below, I join another instance with the same logic as the previous solution. The exit command for the recursive CTE is where n+1<4, which limits the employee_id of interest to 3 indirect managers.

    select a.employee_id, n+1 as n
    from   employees a join cte b on b.employee_id=a.manager_id
    where  n+1<4 
   From here, we can simply select all employee_id produced in the recursive CTE to query the expected result.
    
- Find the Start and End Number of Continuous Ranges
  Since some IDs have been removed from Logs. Write an SQL query to find the start and end number of continuous ranges in table Logs.
  Order the result table by start_id.
  
  SELECT MIN(log_id) AS start_id,
       MAX(log_id) AS end_id
    FROM (
            SELECT log_id, 
                    log_id - ROW_NUMBER() OVER() as diff
                FROM Logs
            )A
    GROUP BY diff;
    
- Number of Calls Between Two Persons
  Write an SQL query to report the number of calls and the total call duration between each pair of distinct persons (person1, person2) where person1 < person2.
  
  WITH CTE AS(
                SELECT from_id as person1, to_id as person2, duration
                    FROM Calls
                UNION ALL
                SELECT to_id as person1, from_id as person2, duration
                FROM Calls
                )
	SELECT person1, person2, COUNT(duration) AS call_count, SUM(duration) AS total_duration       
    		FROM CTE
    		WHERE person1<person2
    		GROUP BY person1, person2;
- The Most Frequently Ordered Products for Each Customer
  Write an SQL query to find the most frequently ordered product(s) for each customer.
  The result table should have the product_id and product_name for each customer_id who ordered at least one order. Return the result table in any order.
  
  WITH order_count AS(
                        SELECT O.customer_id, p.product_id, p.product_name, COUNT(O.product_id) AS order_count
                            FROM Orders O
                            INNER JOIN Products P
                            ON O.product_id = P.product_id
                            GROUP BY O.customer_id, p.product_id, p.product_name 
                        )
                        
                        
    SELECT OC.customer_id, OC.product_id, OC.product_name
        FROM order_count OC
        WHERE OC.order_count = (
                                    SELECT MAX(order_count)
                                        FROM order_count X
                                        WHERE X.customer_id = OC.customer_id
                                    );
- Customers Who Bought Products A and B but Not C
  Write an SQL query to report the customer_id and customer_name of customers who bought products "A", "B" but did not buy the product "C" since we want to recommend them buy this product.
  Return the result table ordered by customer_id.
  
  SELECT customer_id, customer_name
    FROM Customers
    WHERE customer_id IN 
    (
        SELECT customer_id 
            FROM Orders
            WHERE product_name = 'A'
            )AND customer_id IN 
    (
        SELECT customer_id 
            FROM Orders
            WHERE product_name = 'B'
            )AND customer_id NOT IN 
    (
        SELECT customer_id 
            FROM Orders
            WHERE product_name = 'C'
            )
        ORDER BY customer_id;
- NPV Queries
  Write an SQL query to find the npv of all each query of queries table.
  Return the result table in any order.
  
  SELECT q.id, q.year, COALESCE(n.npv,0) AS npv
    FROM NPV n
    Right JOIN Queries q
    ON n.id = q.id AND n.year = q.year
    ORDER BY n.id;
- Write an SQL query to find the missing customer IDs. The missing IDs are ones that are not in the Customers table but are in the range between 1 and the maximum customer_id present in the table.
  Notice that the maximum customer_id will not exceed 100.
  Return the result table ordered by ids in ascending order.
  
  WITH recursive seq AS
    (   
        SELECT 1 AS value
        UNION ALL
        SELECT value+1 from seq
            WHERE value < (SELECT MAX(customer_id) FROM Customers WHERE customer_id < 101)
        )

	SELECT value as ids FROM seq
    		WHERE value NOT IN (SELECT customer_id FROM Customers)
    		ORDER BY ids ASC;

- Write an SQL query to calculate the bonus of each employee. 
  The bonus of an employee is 100% of their salary if the ID of the employee is an odd number and the employee name does not start with the character 'M'. 
  The bonus of an employee is 0 otherwise.
  Return the result table ordered by employee_id.
  
  SELECT employee_id, 
        IF(employee_id % 2 != 0, 
            IF(name NOT LIKE 'M%', salary,0
                ),0
          ) AS bonus
    FROM Employees
    ORDER BY employee_id;

((OR))
SELECT employee_id, 
        IF(employee_id % 2 != 0 AND name NOT LIKE 'M%', salary,0) AS bonus
    FROM Employees
    ORDER BY employee_id;

- Convert Date Format
  Write an SQL query to convert each date in Days into a string formatted as "day_name, month_name day, year".
  
  SELECT DATE_FORMAT(day, "%W, %M %e, %Y") AS day 
    FROM Days;

- Weather Type in Each Country
  Write an SQL query to find the type of weather in each country for November 2019.
  The type of weather is Cold if the average weather_state is less than or equal 15, Hot if the average weather_state is greater than or equal 25 and Warm otherwise.  
  
  SELECT C.country_name, 
        CASE 
            WHEN AVG(W.weather_state) <= 15 THEN "Cold"
            WHEN AVG(W.weather_state) >= 25 THEN "Hot"
            ELSE "Warm"
        END AS weather_type
    FROM Countries C
    INNER JOIN Weather W
    ON C.country_id = W.country_id 
    WHERE MONTH(day) = 11 AND YEAR(day) = 2019
    GROUP BY country_name;
    
- Project Employees I
  Write an SQL query that reports the average experience years of all the employees for each project, rounded to 2 digits.
  
  SELECT P.project_id, 
        ROUND(AVG(experience_years),2) AS average_years
    FROM Project P
    INNER JOIN Employee E
    ON P.employee_id = E.employee_id
    GROUP BY P.project_id;

- Reported Posts
  Write an SQL query that reports the number of posts reported yesterday for each report reason. Assume today is 2019-07-05.
  
  SELECT extra AS report_reason, COUNT(DISTINCT post_id) AS report_count
    FROM Actions
    WHERE action = 'report' AND action_date = '2019-07-04'
    GROUP BY extra;

- Sales Person
  Given three tables: salesperson, company, orders.Output all the names in the table salesperson, who didn’t have sales to company 'RED'.
  
  SELECT name 
    FROM salesperson
    WHERE sales_id NOT IN
                            (
                                SELECT O.sales_id 
                                    FROM orders O
                                    INNER JOIN company C
                                    ON O.com_id = C.com_id AND C.name = 'RED'
                                );
- Fix Product Name Format
  Since table Sales was filled manually in the year 2000, product_name may contain leading and/or trailing white spaces, also they are case-insensitive.
  Write an SQL query to report
  - product_name in lowercase without leading or trailing white spaces.
  - sale_date in the format ('YYYY-MM').
  - total the number of times the product was sold in this month.
  Return the result table ordered by product_name in ascending order. In case of a tie, order it by sale_date in ascending order.
  
  SELECT TRIM(LOWER(product_name)) AS PRODUCT_NAME,
        DATE_FORMAT(sale_date,'%Y-%m') AS SALE_DATE,
        COUNT(*) AS TOTAL
    FROM Sales
    GROUP BY TRIM(LOWER(product_name)), DATE_FORMAT(sale_date,'%Y-%m')
    ORDER BY product_name ASC, sale_date ASC;
    
- Fix Names in a Table
  Write an SQL query to fix the names so that only the first character is uppercase and the rest are lowercase.
  Return the result table ordered by user_id.
  
  SELECT user_id, CONCAT(UCASE(SUBSTRING(name,1,1)),LOWER(SUBSTRING(name,2))) AS name
    FROM Users
    ORDER BY user_id;

- Patients With a Condition
  Write an SQL query to report the patient_id, patient_name all conditions of patients who have Type I Diabetes. Type I Diabetes always starts with DIAB1 prefix
  
  SELECT patient_id, patient_name, conditions
    FROM Patients
    WHERE conditions LIKE '% DIAB1%' OR conditions LIKE 'DIAB1%';
    
- Ads Performance
  A company is running Ads and wants to calculate the performance of each Ad.
  Performance of the Ad is measured using Click-Through Rate (CTR) where:
  Write an SQL query to find the ctr of each Ad.
  Round ctr to 2 decimal points. Order the result table by ctr in descending order and by ad_id in ascending order in case of a tie.
  
  SELECT ad_id,
       Round(Ifnull(( clicks / total ) * 100, 0), 2) ctr
  FROM   (SELECT ad_id,
                -- get sum of all clicks per ad_id
               Sum(CASE
                     WHEN action = 'Clicked' THEN 1
                     ELSE 0
                   END) clicks,
                -- get sum of total clicks and views per ad_id
               Sum(CASE
                     WHEN action = 'Clicked'
                           OR action = 'Viewed' THEN 1
                     ELSE 0
                   END) AS total
        FROM   ads
        GROUP  BY ad_id) tbl
  GROUP  BY ad_id
  ORDER  BY ctr desc, ad_id;

- Game Play Analysis II
  Write a SQL query that reports the device that is first logged in for each player.
  
  WITH CTE AS
(
    SELECT player_id, 
            device_id, 
            ROW_NUMBER() OVER(PARTITION BY player_id ORDER BY event_date) AS rnk
        FROM Activity
    )
    
    SELECT player_id, 
            device_id 
        FROM CTE 
        WHERE rnk = 1;
	
- The Latest Login in 2020
  Write an SQL query to report the latest login for all users in the year 2020. Do not include the users who did not login in 2020.
  
  WITH CTE AS
(
    SELECT user_id, 
            time_stamp AS last_stamp, 
            RANK() OVER(PARTITION BY user_id  ORDER BY time_stamp DESC) AS rnk
        FROM Logins
        WHERE YEAR(time_stamp) = '2020'
    )
    
SELECT user_id, last_stamp
    FROM CTE
     WHERE rnk = 1;

((OR))

SELECT user_id, MAX(time_stamp) AS last_stamp
    FROM Logins
    WHERE YEAR(time_stamp) = '2020'
    GROUP BY user_id; 
    
- Write an SQL query to report the names of all sellers who did not make any sales in 2020.
  Return the result table ordered by seller_name in ascending order
  
  SELECT seller_name
    FROM Seller
    WHERE seller_id NOT IN 
                        (
                            SELECT seller_id
                                FROM Orders
                                WHERE YEAR(sale_date) = 2020
                            )
    ORDER BY seller_name ASC;
